# -*- coding: utf-8 -*-
"""Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L_WhMPobIcbLyYuveBTo3mSbN89EJ9Iz

**Implement a stack data structure in Python**
"""

def create_stack():
    stack = list()            #declaring an empty list
    return stack


# Checking for empty stack
def Isempty(stack):
    return len(stack) == 0


# Inserting items into the stack
def push(stack, n):
    stack.append(n)
    print("pushed item: " + n)


# Removal of an element from the stack
def pop(stack):
    if (Isempty(stack)):
        return "stack is empty"
    else:
        return stack.pop()

# Displaying the stack elements
def show(stack):
    print("The stack elements are:")
    for i in stack:
        print(i)
        
stack = create_stack()
push(stack, str(10))
push(stack, str(20))
push(stack, str(30))
push(stack, str(40))
print("popped item: " + pop(stack))
show(stack)

"""**Implement a Binary Search Tree in Python**"""

# A class that represents the individual node in a BST.
class TreeNode:
    def __init__(self, key):
        self.key = key
        self.l = None
        self.r = None

# Function to insert a new node with the given key.
def new_key_insert(root, new_key):
    if root is None:
        root = TreeNode(new_key)
        return root
    if new_key < root.key:
        root.l = new_key_insert(root.l, new_key)
    else:
        root.r = new_key_insert(root.r, new_key)
    return root
# function to search
def BST_search(self, find_key):
      if self.key == find_key:    
        print("The node is present")
        return
      if find_key < self.key:   
        if self.l:   
            self.l.BST_search(find_key)
        else:
          print("Empty Node")
      else:
        if self.r:
            self.r.BST_search(find_key) 
            return true
        else:   
            print("Empty Node")  

# Function to display the output of the tree
def display(root):
    if root:
        display(root.l)
        print(root.key)
        display(root.r)


r = TreeNode(50)
r = new_key_insert(r, 30)
r = new_key_insert(r, 20)
r = new_key_insert(r, 40)
r = new_key_insert(r, 70)
r = new_key_insert(r, 60)
r = new_key_insert(r, 80)

display(r)
BST_search(r,20)

"""**Anagram Checker**"""

def isAnagram(a, b):
    
    #Unequal Length strings cannot be anagrams
    if len(a) != len(b):
        return False
    
    #sort the first string
    first = sorted(a)
    #sort the second string
    second = sorted(b)
    
    #check if both the strings are the same
    if first == second:
        return True
    else:
        return False
    
#driver code
ans = isAnagram("listen","silent")
print(ans)

"""**FizzBuzz**"""

#for-in loop that traverses numbers from 1 to 100
for num in range(1,101):
  #checking that number is divisible by both 3 and 5
  if(num%3==0 and num%5==0):
    print("FizzBuzz")
  #checking that number is divisible by 3
  elif(num%3 == 0):
    print("Fizz")
  #checking that number is divisible by 5
  elif(num%5 == 0):
    print("Buzz")
  #And if not divisible by either of them print num as it is
  else:
    print(num)

"""** Fibonacci Sequence**"""

def Fibonacci(n):

	# Check if input is 0 then it will
	# print incorrect input
	if n < 0:
		print("Incorrect input")

	# Check if n is 0
	# then it will return 0
	elif n == 0:
		return 0

	# Check if n is 1,2
	# it will return 1
	elif n == 1 or n == 2:
		return 1

	else:
		return Fibonacci(n-1) + Fibonacci(n-2)

# Driver Program
print(Fibonacci(9))